(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{408:function(t,s,a){"use strict";a.r(s);var e=a(12),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("ol",[s("li",[s("p",[t._v("Vue 解决了什么问题")]),t._v(" "),s("p",[t._v("虚拟 dom：dom 操作时非常耗性能的，不再使用原生的 dom 操作节点，极大的解放 dom 操作，但具体操作的还是 dom，不过是换了一种方式。")]),t._v(" "),s("p",[t._v("视图、数据、结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作。")]),t._v(" "),s("p",[t._v("组件化：把一个单页应用中的各种模块拆分到一个一个单独的组件中，便于开发，以及后期的维护")])]),t._v(" "),s("li",[s("p",[t._v("Vue 的生命周期(11 个钩子函数)")]),t._v(" "),s("p",[t._v("beforeCreate(创建前)：在此生命周期函数执行的时候，data 和 methods 中的数据都还没有初始化。")]),t._v(" "),s("p",[t._v("created(创建后)：在此生命周期函数中，data 和 methods 都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早只能在 created 中操作。")]),t._v(" "),s("p",[t._v("beforeMount(载入前)：在此生命周期函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去，此时页面还是旧的。")]),t._v(" "),s("p",[t._v("mounted(载入后)：此时页面和内存中都是最新的数据，这个钩子函数是最早可以操作 dom 节点的方法。")]),t._v(" "),s("p",[t._v("beforeUpdate(更新前)：此时页面中显示的数据还是旧的，但是 data 中的数据是最新的，且页面并未和最新的数据同步。")]),t._v(" "),s("p",[t._v("Updated(更新后)：此时页面显示数据和最新的 data 数据同步。")]),t._v(" "),s("p",[t._v("beforeDestroy(销毁前)：当执行该生命周期函数的时候，实例身上所有的 data，所有的 methods 以及过滤器…等都处于可用状态，并没有真正执行销毁。")]),t._v(" "),s("p",[t._v("destroyed(销毁后)：此时组件以及被完全销毁，实例中的所有的数据、方法、属性、过滤器…等都已经不可用了。")]),t._v(" "),s("p",[t._v("activated(组件激活时)：和上面的 beforeDestroy 和 destroyed 用法差不多，但是如果我们需要一个实例，在销毁后再次出现的话，用 beforeDestroy 和 destroyed 的话，就太浪费性能了。实例被激活时使用，用于重复激活一个实例的时候")]),t._v(" "),s("p",[t._v("deactivated(组件未激活时)：实例没有被激活时。")]),t._v(" "),s("p",[t._v("errorCaptured(错误调用)：当捕获一个来自后代组件的错误时被调用")]),t._v(" "),s("p",[t._v("注意：")]),t._v(" "),s("p",[t._v("父子组件生命周期顺序")]),t._v(" "),s("p",[t._v("父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted")])]),t._v(" "),s("li",[s("p",[t._v("watch、computed 和 methods 的区别")]),t._v(" "),s("p",[t._v("methods 方法：在重新渲染的时候每次都会被重新的调用；")]),t._v(" "),s("p",[t._v("computed是依赖已有的变量来计算一个目标变量，大多数情况都是多个变量凑在一起计算出一个变量，并且computed具有缓存机制，依赖值不变的情况下其会直接读取缓存进行复用，computed不能进行异步操作")]),t._v(" "),s("p",[t._v("watch是监听某一个变量的变化，并执行相应的回调函数，通常是一个变量的变化决定多个变量的变化，watch可以进行异步操作")]),t._v(" "),s("p",[t._v("简单记就是：一般情况下computed是多对一，watch是一对多")])]),t._v(" "),s("li",[s("p",[t._v("Vue.js 的特点")]),t._v(" "),s("p",[t._v("简洁：页面由 HTML 模板+Json 数据+Vue 实例组成\n数据驱动：自动计算属性和追踪依赖的模板表达式")]),t._v(" "),s("p",[t._v("组件化：用可复用、解耦的组件来构造页面")]),t._v(" "),s("p",[t._v("轻量：代码量小，不依赖其他库")]),t._v(" "),s("p",[t._v("快速：精确有效批量 DOM 更新")]),t._v(" "),s("p",[t._v("模板友好：可通过 npm，bower 等多种方式安装，很容易融入")])]),t._v(" "),s("li",[s("p",[t._v("插槽的理解")]),t._v(" "),s("p",[t._v("插槽用于决定将所携带的内容，插入到子组件指定的某个位置，但内容必须在父组件中子组件的标签内定义，在子组件中用标签接收。slot 是组件内部的占位符。")])]),t._v(" "),s("li",[s("p",[t._v("vue-router 有哪几种导航钩子")]),t._v(" "),s("p",[t._v("全局导航钩子：一般用来判断权限，以及页面丢失时需要执行的操作；")]),t._v(" "),s("p",[t._v("beforeEach（）每次路由进入之前执行的函数。")]),t._v(" "),s("p",[t._v("afterEach（）每次路由进入之后执行的函数。")]),t._v(" "),s("p",[t._v("beforeResolve（）2.5 新增")]),t._v(" "),s("p",[t._v("单个路由（实例钩子）：某个指定路由跳转时需要执行的逻辑。")]),t._v(" "),s("p",[t._v("beforeEnter（）")]),t._v(" "),s("p",[t._v("beforeLeave（）")]),t._v(" "),s("p",[t._v("组件路由钩子：")]),t._v(" "),s("p",[t._v("beforeRouteEnter（）")]),t._v(" "),s("p",[t._v("beforeRouteLeave（）")]),t._v(" "),s("p",[t._v("beforeRouteUpdate（）")])]),t._v(" "),s("li",[s("p",[t._v("vue 组件中的 data 为什么是一个函数")]),t._v(" "),s("p",[t._v("data 是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。Object 是引用数据类型，如果不用 function 返回，每个组件的 data 都是内存的同一个地址，一个数据改变了其他也改变了。")])]),t._v(" "),s("li",[s("p",[t._v("路由懒加载")]),t._v(" "),s("p",[t._v("使用原因：在单页应用中，如果没有应用懒加载，运用 webpack 打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，延时过长，不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时")]),t._v(" "),s("p",[t._v("原理：vue 异步组件技术：异步加载，vue-router 配置路由 , 使用 vue 的异步组件技术 , 实现按需加载。")])]),t._v(" "),s("li",[s("p",[t._v("Vue.js 介绍")]),t._v(" "),s("p",[t._v("Vue.js 是一个轻巧、高性能、可组件化的 MVVM 库，同时拥有非常容易上手的 API；Vue.js 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。数据驱动+组件化的前端开发。通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。")])]),t._v(" "),s("li",[s("p",[t._v("请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法")]),t._v(" "),s("p",[t._v("assets 文件夹是放静态资源；")]),t._v(" "),s("p",[t._v("components 是放组件；")]),t._v(" "),s("p",[t._v("router 是定义路由相关的配置;")]),t._v(" "),s("p",[t._v("view 视图；")]),t._v(" "),s("p",[t._v("app.vue 是一个应用主组件；")]),t._v(" "),s("p",[t._v("main.js 是入口文件")])]),t._v(" "),s("li",[s("p",[t._v("Vue 中 key 值的作用")]),t._v(" "),s("p",[t._v("当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key 的作用主要是为了高效的更新虚拟 DOM。")]),t._v(" "),s("p",[t._v("v-bind：给元素绑定属性")]),t._v(" "),s("p",[t._v("v-on：给元素绑定事件")]),t._v(" "),s("p",[t._v("v-html：给元素绑定数据，且该指令可以解析 html 标签")]),t._v(" "),s("p",[t._v("v-text：给元素绑定数据，不解析标签")]),t._v(" "),s("p",[t._v("v-model：数据双向绑定")]),t._v(" "),s("p",[t._v("v-for：遍历数组")]),t._v(" "),s("p",[t._v("v-if：条件渲染指令，动态在 DOM 内添加或删除 DOM 元素")]),t._v(" "),s("p",[t._v("v-else：条件渲染指令，必须跟 v-if 成对使用")]),t._v(" "),s("p",[t._v("v-else-if：判断多层条件，必须跟 v-if 成对使用")]),t._v(" "),s("p",[t._v("v-cloak：解决插值闪烁问题")]),t._v(" "),s("p",[t._v("v-once：只渲染元素或组件一次")]),t._v(" "),s("p",[t._v("v-pre：跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度")]),t._v(" "),s("p",[t._v("v-show：条件渲染指令，将不符合条件的数据隐藏(display. none)")])]),t._v(" "),s("li",[s("p",[t._v("v-for 与 v-if 的优先级")]),t._v(" "),s("p",[t._v("v-for 比 v-if 优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候。")]),t._v(" "),s("p",[t._v("v-if和v-for不建议用在同一标签？")]),t._v(" "),s("p",[t._v("在Vue2中，v-for优先级是高于v-if的，咱们来看例子")])])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"item in [1, 2, 3, 4, 5, 6, 7]"')]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"item !== 3"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("item"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("p",[t._v("上面的写法是v-for和v-if同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"item in list"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("item"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("computed")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("list")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("filter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("item")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" item "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ol",{attrs:{start:"14"}},[s("li",[s("p",[t._v("Vue 怎么兼容 IE")]),t._v(" "),s("p",[t._v("使用 babel-polyfill 插件(建议你先去了解一下，这样面试时被问到可以回答的上来)")])]),t._v(" "),s("li",[s("p",[t._v("MVVM 的理解")]),t._v(" "),s("p",[t._v("MVVM 就是 Model-View-ViewModel 的缩写，MVVM 将视图和业务逻辑分开。")]),t._v(" "),s("p",[t._v("View：视图层，Model 数据模型，而 ViewModel 是把两者建立通信的桥梁。")]),t._v(" "),s("p",[t._v("在 MVVM 框架下，View 和 Model 之间没有直接的联系，而是通过 ViewModel 进行交互。View 和 ViewModel 之间以及 Model 和 ViewModel 之间的交互都是双向的，因此 view 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反映到 View 上。可以说它们两者是实时更新的，互相影响。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，因此开发者只需要关注业务逻辑，不需要手动操作 DOM，也不需要关注数据状态的同步问题，这些都由 MVVM 统一管理。")])]),t._v(" "),s("li",[s("p",[t._v("为什么 data 是一个函数")]),t._v(" "),s("p",[t._v("组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果")])]),t._v(" "),s("li",[s("p",[t._v("Vue 组件通讯有哪几种方式")]),t._v(" "),s("p",[t._v("父组件传值给子组件，子组件使用props进行接收")]),t._v(" "),s("p",[t._v("子组件传值给父组件，子组件使用$emit+事件对父组件进行传值")]),t._v(" "),s("p",[t._v("组件中可以使用$parent和$children获取到父组件实例和子组件实例，进而获取数据")]),t._v(" "),s("p",[t._v("使用$attrs和$listeners，在对一些组件进行二次封装时可以方便传值，例如A->B->C")]),t._v(" "),s("p",[t._v("使用$refs获取组件实例，进而获取数据")]),t._v(" "),s("p",[t._v("使用Vuex进行状态管理")]),t._v(" "),s("p",[t._v("使用eventBus进行跨组件触发事件，进而传递数据")]),t._v(" "),s("p",[t._v("使用provide和inject，官方建议我们不要用这个，我在看ElementUI源码时发现大量使用")]),t._v(" "),s("p",[t._v("浏览器本地缓存，例如localStorage")])]),t._v(" "),s("li",[s("p",[t._v("v-if 和 v-show 的区别")]),t._v(" "),s("p",[t._v("v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。")]),t._v(" "),s("p",[t._v("v-show 会被编译成指令，条件不满足时控制样式将对应节点隐藏 （display:none）")])]),t._v(" "),s("li",[s("p",[t._v("Vue 怎么重置 data")]),t._v(" "),s("p",[t._v("使用 Object.assign()，vm.$data可以获取当前状态下的data，vm.$options.data 可以获取到组件初始化状态下的 data。")])])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("assign")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$options"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("data")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ol",{attrs:{start:"20"}},[s("li",[s("p",[t._v("组件中写 name 选项有什么作用")]),t._v(" "),s("p",[t._v("项目使用 keep-alive 时，可搭配组件的 name 进行缓存过滤。")]),t._v(" "),s("p",[t._v("DOM 做递归组件时需要调用自身 name")]),t._v(" "),s("p",[t._v("vue-devtools 调试工具里显示的组件名称是由 vue 中组件 name 决定的")])]),t._v(" "),s("li",[s("p",[t._v("route 和 router")]),t._v(" "),s("p",[t._v("route 是“路由信息对象”，包括 path,params,hash,query,fullPath,matched,name 等路由信息参数。")]),t._v(" "),s("p",[t._v("router 是“路由实例对象”，包括了路由的跳转方法(push、go)，钩子函数等。")])]),t._v(" "),s("li",[s("p",[t._v("Vue 修饰符有哪些")]),t._v(" "),s("p",[t._v("事件修饰符")]),t._v(" "),s("p",[t._v(".stop 阻止事件继续传播")]),t._v(" "),s("p",[t._v(".prevent 阻止标签默认行为")]),t._v(" "),s("p",[t._v(".capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理")]),t._v(" "),s("p",[t._v(".self 只当在 event.target 是当前元素自身时触发处理函数")]),t._v(" "),s("p",[t._v(".once 事件将只会触发一次")]),t._v(" "),s("p",[t._v(".passive 告诉浏览器你不想阻止事件的默认行为")])])]),t._v(" "),s("p",[t._v("中级（一般）")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("nextTick 的理解")]),t._v(" "),s("p",[t._v("使用 nextTick 的原因：Vue 是异步修改 DOM 的，并且不鼓励开发者直接接触 DOM，但是有时候需要必须对数据更改后的 DOM 元素做相应的处理，但是获取到的 DOM 数据并不是更改后的数据，这时候就需要 this.$nextTick()；")]),t._v(" "),s("p",[t._v("原理：Vue 通过异步队列控制 DOM 更新和 nextTick 回调函数先后执行的方式。")]),t._v(" "),s("p",[t._v("使用：")])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//HTML")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("button @click"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"change()"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("按钮"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("button"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1 ref"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"gss"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//JS")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"app"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("data")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("msg")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"123"')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("methods")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("change")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("msg "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"456"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("refs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"gss"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innerHTML"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//123")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\\"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$nextTick")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("refs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"gss"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innerHTML"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//456")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("虚拟 DOM 原理")]),t._v(" "),s("p",[t._v("虚拟 DOM，其实就是用对象的方式取代真实的 DOM 操作，把真实的 DOM 操作放在内存当中，在内存中的对象里做模拟操作。当页面打开时浏览器会解析 HTML 元素，构建一颗 DOM 树，将状态全部保存起来，在内存当中模拟我们真实的 DOM 操作，操作完后又会生成一颗 dom 树，两颗 DOM 树进行比较，根据 diff 算法比较两颗 DOM 树不同的地方，只渲染一次不同的地方。")])]),t._v(" "),s("li",[s("p",[t._v("不需要响应式的数据应该怎么处理？")]),t._v(" "),s("p",[t._v("在我们的Vue开发中，会有一些数据，从始至终都未曾改变过，这种死数据，既然不改变，那也就不需要对他做响应式处理了，不然只会做一些无用功消耗性能，比如一些写死的下拉框，写死的表格数据，这些数据量大的死数据，如果都进行响应式处理，那会消耗大量性能。")])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 方法一：将数据定义在data之外")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("data")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list3 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list4 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list5 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 方法二：Object.freeze()")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("data")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("list1")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("freeze")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("xxxxxxxxxxxxxxxxxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("list2")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("freeze")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("xxxxxxxxxxxxxxxxxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("list3")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("freeze")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("xxxxxxxxxxxxxxxxxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("list4")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("freeze")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("xxxxxxxxxxxxxxxxxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("list5")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("freeze")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("xxxxxxxxxxxxxxxxxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ol",{attrs:{start:"4"}},[s("li",[s("p",[t._v("Proxy 相比于 defineProperty 的优势")]),t._v(" "),s("p",[t._v("Vue3.0 摒弃了 Object.defineProperty，改为基于 Proxy 的观察者机制探索。")]),t._v(" "),s("p",[t._v("首先说一下 Object.defineProperty 的缺点：")]),t._v(" "),s("p",[t._v("Object.defineProperty 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实施响应。")]),t._v(" "),s("p",[t._v("Object.defineProperty 只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历。Vue2.X 里，是通过递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历，显然如果能劫持一个完整的对象才是更好的选择。")]),t._v(" "),s("p",[t._v("而要取代它的 Proxy 有以下两个优点")]),t._v(" "),s("p",[t._v("可以劫持整个对象，并返回一个新对象。")]),t._v(" "),s("p",[t._v("有多种劫持操作(13 种)")]),t._v(" "),s("p",[t._v("补充：")]),t._v(" "),s("p",[t._v("Proxy 是 ES6 新增的一个属性，翻译过来的意思就是代理，用在这里表示由它来“代理”某些操作。Proxy 让我们能够以简洁易懂的方式控制外部对象的访问，其功能非常类似于设计模式中的代理模式。")]),t._v(" "),s("p",[t._v("Proxy 可以理解为，在目标对象之前设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。")]),t._v(" "),s("p",[t._v("使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑(如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等)。从而可以让对象只需要关注核心逻辑，达到关注点分离，降低对象复杂度等目的。")]),t._v(" "),s("ol",[s("li",[t._v("virtual-dom 原理实现(虚拟 dom)")])]),t._v(" "),s("p",[t._v("virtual-dom(简称 vdom)的概念大规模的推广还是得益于 react 的出现，virtual-dom 也是 react 这个框架的非常重要的特性之一。相比于频繁的手动去操作 dom 而带来性能问题，vdom 很好的将 dom 做了一层映射关系，进而将在我们本需要直接进行 dom 的一系列操作，映射到了操作 vdom，而 vdom 上定义了关于真实 dom 进行的创建节点，删除节点，添加节点等一系列复杂的 dom 操作，并将这些操作放到 vdom 中进行，这样就通过操作 vdom 来提高直接操作的 dom 的效率和性能。")])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("   在vue的整个应用生命周期当中，每次需要更新视图的时候便会使用vdom，vdom算法是基于"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),t._v("snabbdom"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),t._v("算法所做的修改。\n")])])]),s("p",[t._v("实现：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v("用js对象构造一个虚拟的dom树，插入到文档中；\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v("状态变更时，记录新树和旧树的差异；\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v("把上面的差异构建到真正的dom中。\n")])])]),s("ol",{attrs:{start:"6"}},[s("li",[t._v("vue-router\n单页面路由跳转的方式：")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("哈希默认"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("模式：使用 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("URL")]),t._v(" hash 值来作路由。默认模式。\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("history")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("history"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("模式： 依赖 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTML5")]),t._v(" History "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("API")]),t._v(" 和服务器配置。查看 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTML5")]),t._v(" History 模式。\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("abstract模式")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("严格模式"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("：支持所有 JavaScript 运行环境，如 Node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js 服务器端。\n根据mode参数来决定采用哪一种方式。\nvue"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("router的实现原理")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("核心"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("：更新视图但不重新请求页面。\n")])])]),s("p",[t._v("hash模式：通过#号后面的内容的更改，触发hashchange事件，实现路由切换")]),t._v(" "),s("p",[t._v("history模式：通过pushState和replaceState切换url，实现路由切换，需要后端配合")]),t._v(" "),s("p",[t._v("vue-router 登陆权限的判断")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("vue"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("router的登陆权限判断主要是在全局钩子函数中进行的\n我们在router"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js文件中的定义路由里\n将需要登陆权限的页面加上meta属性，值是对象的形式，然后在该对象中自定义一个属性\n属性值就是一个Boolean值，这时候在main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js文件的全局钩子函数中进行判断\n如果需要跳转的页面的自定义属性值为"),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("，那么将进行判断其是否登录，如果没有登录\n则告诉用户登录，如果有登录，那么进行页面跳转\n")])])]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("routes")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/home"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Home"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("components")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("Home\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("meta")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("requireAuth")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("ol",{attrs:{start:"7"}},[s("li",[s("p",[t._v("Vue3.0 的了解")]),t._v(" "),s("p",[t._v("大致有三个点，第一个是关于提出的新 API setup()函数，第二个说了对于 Typescript 的支持，最后说了关于替换 Object.defineProperty 为 Proxy 的支持。详细说了下关于 Proxy 代替带来的性能上的提升，因为传统的原型链拦截的方法，无法检测对象及数组的一些更新操作，但使用 Proxy 又带来了浏览器兼容问题。")])]),t._v(" "),s("li",[s("p",[t._v("vue-cli 替我们做了哪些工作")]),t._v(" "),s("p",[t._v("vue-cli 是基于 Vue.js 进行快速开发的完整系统，也可以理解成是很多 npm 包的集合。")]),t._v(" "),s("p",[t._v("vue-cli 完成的功能：")]),t._v(" "),s("p",[t._v(".vue 文件 --\x3e .js 文件")]),t._v(" "),s("p",[t._v("ES6 语法 --\x3e ES5 语法")]),t._v(" "),s("p",[t._v("Sass,Less,Stylus --\x3e CSS")]),t._v(" "),s("p",[t._v("对 jpg,png,font 等静态资源的处理")]),t._v(" "),s("p",[t._v("热更新")]),t._v(" "),s("p",[t._v("定义环境变量，区分 dev 和 production 模式")]),t._v(" "),s("p",[t._v("如果开发者需要补充或修改默认设置，需要在 package.json 同级下新建一个 vue.config.js 文件")])]),t._v(" "),s("li",[s("p",[t._v("axios 的拦截")])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//响应拦截")]),t._v("\naxios"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("interceptors"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("response"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("use")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("response")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//对响应数据做点什么")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" response"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//对错误响应做点什么")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//请求拦截")]),t._v("\naxios"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("interceptors"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("request"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("use")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("config")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//在发送请求之前做些什么")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" config\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//对请求错误做些什么")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ol",{attrs:{start:"10"}},[s("li",[s("p",[t._v("Vue2.0 响应式数据的原理")]),t._v(" "),s("p",[t._v("整体思路是数据劫持+观察者模式")]),t._v(" "),s("p",[t._v("对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。")])]),t._v(" "),s("li",[s("p",[t._v("Vue 如何检测数组变化")]),t._v(" "),s("p",[t._v("数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对 7 种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写(AOP 切片思想)")]),t._v(" "),s("p",[t._v("所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新")])]),t._v(" "),s("li",[s("p",[t._v("双向绑定的原理？数据劫持原理")]),t._v(" "),s("p",[t._v("mvvm 双向绑定，采用"),s("strong",[s("strong",[t._v("数据劫持结合发布者-订阅者模式")])]),t._v("的方式，通过 Object.defineProperty() 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。")]),t._v(" "),s("p",[t._v("几个要点：")]),t._v(" "),s("p",[t._v("1、实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者")]),t._v(" "),s("p",[t._v("2、实现一个指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数")]),t._v(" "),s("p",[t._v("3、实现一个 Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图")]),t._v(" "),s("p",[t._v("4、mvvm 入口函数，整合以上三者")]),t._v(" "),s("p",[t._v("具体步骤：")]),t._v(" "),s("ol",[s("li",[t._v("需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter")])]),t._v(" "),s("p",[t._v("这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")])]),t._v(" "),s("li",[s("p",[t._v("Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:")])])]),t._v(" "),s("p",[t._v("· 在自身实例化时往属性订阅器(dep)里面添加自己")]),t._v(" "),s("p",[t._v("· 自身必须有一个 update() 方法")]),t._v(" "),s("p",[t._v("· 待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。")]),t._v(" "),s("p",[t._v("MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过Observer来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。")])]),t._v(" "),s("li",[s("p",[t._v("v-for 为什么要加 key")]),t._v(" "),s("p",[t._v("如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速")])]),t._v(" "),s("li",[s("p",[t._v("vue-router 路由钩子函数是什么 执行顺序是什么")]),t._v(" "),s("p",[t._v("路由钩子的执行流程, 钩子函数种类有:全局守卫、路由守卫、组件守卫")]),t._v(" "),s("p",[t._v("完整的导航解析流程:")]),t._v(" "),s("p",[t._v("导航被触发。")]),t._v(" "),s("p",[t._v("在失活的组件里调用 beforeRouteLeave 守卫。")]),t._v(" "),s("p",[t._v("调用全局的 beforeEach 守卫。")]),t._v(" "),s("p",[t._v("在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。")]),t._v(" "),s("p",[t._v("在路由配置里调用 beforeEnter。")]),t._v(" "),s("p",[t._v("解析异步路由组件。")]),t._v(" "),s("p",[t._v("在被激活的组件里调用 beforeRouteEnter。")]),t._v(" "),s("p",[t._v("调用全局的 beforeResolve 守卫 (2.5+)。")]),t._v(" "),s("p",[t._v("导航被确认。")]),t._v(" "),s("p",[t._v("调用全局的 afterEach 钩子。")]),t._v(" "),s("p",[t._v("触发 DOM 更新。")]),t._v(" "),s("p",[t._v("调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。")])]),t._v(" "),s("li",[s("p",[t._v("谈一下对 vuex 的个人理解")]),t._v(" "),s("p",[t._v("定义：Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式储存管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。")]),t._v(" "),s("p",[t._v("使用场景：需要构建一个中大型单页应用，您很可能会考虑如何更好的在组件外部管理状态，Vuex将会成为自然而然的选择。")]),t._v(" "),s("p",[t._v("优点：当你在state中定义了一个数据之后，可以在所在项目中的任何一个组件里进行获取、进行修改、并且你的修改可以得到全局的响应变更。")]),t._v(" "),s("p",[t._v("主要包括以下几个模块：")]),t._v(" "),s("p",[t._v("State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。")]),t._v(" "),s("p",[t._v("Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。")]),t._v(" "),s("p",[t._v("Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。")]),t._v(" "),s("p",[t._v("Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。")]),t._v(" "),s("p",[t._v("Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。")]),t._v(" "),s("p",[t._v("Vuex的运行机制：Vuex提供数据（state）来驱动试图（vue components），通过dispath派发actions，在其中可以做一些异步的操作，然后通过commit来提交mutations，最后mutations来更改state。")])]),t._v(" "),s("li",[s("p",[t._v("Vuex 页面刷新数据丢失怎么解决")]),t._v(" "),s("p",[t._v("需要做 vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件")]),t._v(" "),s("p",[t._v("推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中")]),t._v(" "),s("p",[t._v("(注实际开发中使用sessionStorage来保存，原因是localStorage在同一浏览器中多个账户登录保存到localStroage会出问题)")])]),t._v(" "),s("li",[s("p",[t._v("Vuex 为什么要分模块并且加命名空间")]),t._v(" "),s("p",[t._v("模块. 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。")])]),t._v(" "),s("li",[s("p",[t._v("vue 中使用了哪些设计模式")]),t._v(" "),s("p",[t._v("1.工厂模式 - 传入参数即可创建实例")]),t._v(" "),s("p",[t._v("虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode")]),t._v(" "),s("p",[t._v("2.单例模式 - 整个程序有且仅有一个实例")]),t._v(" "),s("p",[t._v("vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉")]),t._v(" "),s("p",[t._v("3.发布-订阅模式 (vue 事件机制)")]),t._v(" "),s("p",[t._v("4.观察者模式 (响应式数据原理)")]),t._v(" "),s("p",[t._v("5.装饰模式: (@装饰器的用法)")]),t._v(" "),s("p",[t._v("策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略")])]),t._v(" "),s("li",[s("p",[t._v("你都做过哪些 Vue 的性能优化")]),t._v(" "),s("p",[t._v("这里只列举针对 Vue 的性能优化 整个项目的性能优化是一个大工程 可以另写一篇性能优化的文章 哈哈")]),t._v(" "),s("p",[t._v("对象层级不要过深，否则性能就会差")]),t._v(" "),s("p",[t._v("不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）")]),t._v(" "),s("p",[t._v("v-if 和 v-show 区分使用场景")]),t._v(" "),s("p",[t._v("computed 和 watch 区分使用场景")]),t._v(" "),s("p",[t._v("v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if")]),t._v(" "),s("p",[t._v("大数据列表和表格性能优化-虚拟列表/虚拟表格")]),t._v(" "),s("p",[t._v("防止内部泄漏，组件销毁后把全局变量和事件销毁")]),t._v(" "),s("p",[t._v("图片懒加载")]),t._v(" "),s("p",[t._v("路由懒加载")]),t._v(" "),s("p",[t._v("第三方插件的按需引入")]),t._v(" "),s("p",[t._v("适当采用 keep-alive 缓存组件")]),t._v(" "),s("p",[t._v("防抖、节流运用")]),t._v(" "),s("p",[t._v("服务端渲染 SSR or 预渲染")])]),t._v(" "),s("li",[s("p",[t._v("描述下 vue 从初始化页面–>修改数据–>刷新页面 UI 过程？")]),t._v(" "),s("p",[t._v("当 Vue 进入初始化阶段时，一方面 Vue 会遍历 data 中的属性，并用 Object.defineProperty 将它转化成 getter/setterd 的形式，实现数据劫持；另一方面，Vue 的指令编译器 Compiler 对元素节点的各个指令进行解析，初始化视图，并订阅 Watcher 来更新视图，此时 Watcher 会将自己添加到消息订阅器 Dep 中，此时初始化完毕。")]),t._v(" "),s("p",[t._v("当数据发生变化时，触发 Observer 中 setter 方法，立即调用 Dep.notify( )，Dep 这个数组开始遍历所有的订阅者，并调用其 update 方法，Vue 内部再通过 diff 算法，patch 相应的更新完成对订阅者视图的改变。")])]),t._v(" "),s("li",[s("p",[t._v("scoped 原理及穿透方法")]),t._v(" "),s("p",[t._v("vue 中的 scoped 通过在 DOM 结构以及 css 样式上加唯一不重复的标记：data-v-hash 的方式，以保证唯一(通过 PostCSS 转译)，达到样式私有模块化的目的。")]),t._v(" "),s("p",[t._v("scoped 的 3 条渲染规则：")]),t._v(" "),s("p",[t._v("给 HTML 的 DOM 节点加一个不重复的 data 属性，来表示它的唯一性；")]),t._v(" "),s("p",[t._v("在每句 css 选择器末尾（编译后的生成的 css 语句）加一个当前组件的 data 属性选择器来私有化样式；")]),t._v(" "),s("p",[t._v("如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的 data 属性。")])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v(" 在做项目中，会遇到这么一个问题，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，\n 而又不想去除scoped属性造成组件之间的样式污染。\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v("不使用scopeds省略（不推荐）\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v("在模板中使用两次style标签\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("scoped穿透："),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("deep"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\n")])])]),s("p",[t._v("PostCSS：使用 JS 插件转换 CSS 的工具。这些插件可以支持变量和 mixins，转换将来的 css 语法，内联图像等。Autoprefixer 是一种非常流行的 PostCSS 插件。")]),t._v(" "),s("ol",{attrs:{start:"22"}},[s("li",[s("p",[t._v("Vue 和 React 的区别")]),t._v(" "),s("p",[t._v("监听数据变化的实现原理不同：Vue 通过 getter/setter 以及一些函数的劫持，能精确快速的计算出 vdom 的差异。这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。React 默认是通过比较引用的方式进行的，如果不优化，每当应用的状态被改变时，全部子组件都会重新渲染，可能导致大量不必要的 VDOM 的重新渲染。")]),t._v(" "),s("p",[t._v("数据流的不同：Vue 中默认支持双向绑定，组件与 DOM 之间可以通过 v-model 双向绑定。但是，父子组件之间，props 在 2.x 版本是单向数据流。React 一直提倡的是单向数据流。")]),t._v(" "),s("p",[t._v("模板渲染方式的不同：React 是通过 JSX 渲染模板，而 Vue 是通过一种拓展的 HTML 语法进行渲染")])]),t._v(" "),s("li",[s("p",[t._v("首屏加载优化")]),t._v(" "),s("p",[t._v("把不常改变的库放到 index.html 中，通过 cdn 引入")]),t._v(" "),s("p",[t._v("然后找到 build/webpack.base.conf.js 文件，在 module.exports = { } 中添加以下代码：")])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("externals")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v("'vue'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Vue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v("'vue-router'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'VueRouter'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v("'element-ui'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'ELEMENT'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),s("p",[t._v("vue 路由懒加载")]),t._v(" "),s("p",[t._v("不生成 map 文件，找到 config/index.js 文件，修改为 productionSourcceMap：false")]),t._v(" "),s("p",[t._v("vue 组件尽量不要全局引入")]),t._v(" "),s("p",[t._v("使用更轻量级的工具库")]),t._v(" "),s("p",[t._v("开启 gzip 压缩：这个优化是两方面的，前端将文件打包成.gz 文件，然后通过 nginx 的配置，让浏览器直接解析.gz 文件。")]),t._v(" "),s("p",[t._v("首页单独做服务端渲染：如果首页真的有瓶颈，可以考虑用 node 单独做服务端渲染，而下面的子页面仍用 spa 单页的方式交互。这里不推荐直接用 nuxt.js 服务端渲染方案，因为这样一来增加了学习成本，二来服务端的维护成本也会上升，有时在本机测试没问题，在服务端跑就有问题，为了省心，还是最大限度的使用静态页面较好。\n24. $set 是干嘛用的")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("template"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("button @click"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"change()"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("点击"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("button"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("template"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("script"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("data")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("arr")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("methods")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("change")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//[1,0,3]")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("p",[t._v("上面就是一个典型的例子，当我们点击按钮想要根据数组 arr 的下标改变其元素的时候，你会发现 data 中的数据改变了，但是页面中的数据并没有改变。这时候就需要$set 出场了。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("change")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("改变"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("添加 对象属性的时候"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data 实例"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"属性名(添加的属性名)"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"属性值(添加的属性值)"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n改变"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("添加 数组属性的时候"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\\"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data 实例"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("数组下标"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"改变后的元素(添加的元素)"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("复制代码\n")])])]),s("p",[t._v("原因：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("vue 在创建实例的时候把data深度遍历所有属性"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("并使用 Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("defineProperty \n把这些属性全部转为 getter"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("setter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("让 Vue 追踪依赖，在属性被访问和修改时通知变化\n所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的\n")])])]),s("p",[t._v("当你在对象上新加了一个属性 newProperty,当前新加的这个属性并没有加入 vue 检测数据更新的机制(因为是在初始化之后添加的),vue.$set 是能让 vue 知道你添加了属性, 它会给你做处理.")]),t._v(" "),s("ol",{attrs:{start:"25"}},[s("li",[t._v('vue 中"dependencies"，"devDependencies"是什么？')])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("使用 npm i 【包名】 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("save"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("dev 安装的包，会被写入到 devDependencies 对象里面去；\n \n而使用 npm i 【包名】 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("save 安装的包，则被写入到 dependencies 对象里面去。\n \n那么 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json 文件里面的 devDependencies  和 dependencies 对象有什么区别呢？\n \ndevDependencies  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("里面的插件")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("比如各种loader，babel全家桶及各种webpack的插件等"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("只用于开发环境，\n不用于生产环境，因此不需要打包；而 dependencies  是需要发布到生产环境的，是要打包的。\n")])])]),s("ol",{attrs:{start:"26"}},[s("li",[s("p",[t._v("Vue的SSR是什么？有什么好处？")]),t._v(" "),s("p",[t._v("SSR就是服务端渲染. 比如基于Vue.js的SSR框架——Nuxt.js")]),t._v(" "),s("p",[t._v("基于nodejs serve服务环境开发，所有html代码在服务端渲染")]),t._v(" "),s("p",[t._v("数据返回给前端，然后前端进行“激活”，即可成为浏览器识别的html代码")]),t._v(" "),s("p",[t._v("SSR首次加载更快，有更好的用户体验，有更好的seo优化，因为爬虫能看到整个页面的内容，如果是vue项目，由于数据还要经过解析，这就造成爬虫并不会等待你的数据加载完成，所以其实Vue项目的seo体验并不是很好")])])]),t._v(" "),s("p",[t._v("高级（困难）")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("Vue.mixin 的使用场景和原理")]),t._v(" "),s("p",[t._v("在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 Vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。")])]),t._v(" "),s("li",[s("p",[t._v("nextTick 使用场景和原理")]),t._v(" "),s("p",[t._v("nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法")])]),t._v(" "),s("li",[s("p",[t._v("keep-alive 使用场景和原理")]),t._v(" "),s("p",[t._v("keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。")]),t._v(" "),s("p",[t._v("常用的两个属性 include/exclude，允许组件有条件的进行缓存。")]),t._v(" "),s("p",[t._v("两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。")]),t._v(" "),s("p",[t._v("keep-alive 的中还运用了 LRU(最近最少使用) 算法，选择最近最久未使用的组件予以淘汰。")])]),t._v(" "),s("li",[s("p",[t._v("Vue.extend 作用和原理")]),t._v(" "),s("p",[t._v("官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。")]),t._v(" "),s("p",[t._v("其实就是一个子类构造器 是 Vue 组件的核心 api 实现思路就是使用原型继承的方法返回了 Vue 的子类 并且利用 mergeOptions 把传入组件的 options 和父类的 options 进行了合并")])]),t._v(" "),s("li",[s("p",[t._v("写过自定义指令吗 原理是什么")]),t._v(" "),s("p",[t._v("指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。")]),t._v(" "),s("p",[t._v("自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind")]),t._v(" "),s("p",[t._v("原理")]),t._v(" "),s("p",[t._v("1.在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性")]),t._v(" "),s("p",[t._v("2.通过 genDirectives 生成指令代码")]),t._v(" "),s("p",[t._v("3.在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子")]),t._v(" "),s("p",[t._v("当执行指令对应钩子函数时，调用对应指令定义的方法")])]),t._v(" "),s("li",[s("p",[t._v("Vue 模板编译原理")])])]),t._v(" "),s("p",[t._v("Vue 的编译过程就是将 template 转化为 render 函数的过程 分为以下三步")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("第一步是将 模板字符串 转换成 element ASTs（解析器）\n第二步是对 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("AST")]),t._v(" 进行静态节点标记，主要用来做虚拟"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("的渲染优化（优化器）\n第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）\n")])])]),s("ol",{attrs:{start:"7"}},[s("li",[s("p",[t._v("生命周期钩子是如何实现的\nVue 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的的生命周期钩子订阅好（内部采用数组的方式存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）")])]),t._v(" "),s("li",[s("p",[t._v("函数式组件使用场景和原理\n函数式组件与普通组件的区别")])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v("函数式组件需要在声明组件是指定 functional"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v("不需要实例化，所以没有"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v("通过render函数的第二个参数context来代替\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v("没有生命周期钩子函数，不能使用计算属性，watch\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.")]),t._v("不能通过$emit 对外暴露事件，调用事件只能通过context"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("listeners"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("click的方式调用外部传入的事件\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5.")]),t._v("因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6.")]),t._v("函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n而普通组件所有未声明的属性都解析到$attrs里面，并自动挂载到组件根元素上面\n")])])]),s("p",[t._v("优点 1.由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件 2.函数式组件结构比较简单，代码结构更清晰")]),t._v(" "),s("p",[t._v("使用场景：")]),t._v(" "),s("p",[t._v("一个简单的展示组件，作为容器组件使用 比如 router-view 就是一个函数式组件")]),t._v(" "),s("p",[t._v("“高阶组件”——用于接收一个组件作为参数，返回一个被包装过的组件")]),t._v(" "),s("ol",{attrs:{start:"9"}},[s("li",[s("p",[t._v("能说下 vue-router 中常用的路由模式实现原理吗")]),t._v(" "),s("p",[t._v("hash 模式")]),t._v(" "),s("p",[t._v("location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。")]),t._v(" "),s("p",[t._v("可以为 hash 的改变添加监听事件")])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hashchange"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" funcRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了")]),t._v(" "),s("p",[t._v("特点：兼容性好但是不美观")]),t._v(" "),s("p",[t._v("history 模式")]),t._v(" "),s("p",[t._v("利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。")]),t._v(" "),s("p",[t._v("这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。")]),t._v(" "),s("ol",{attrs:{start:"10"}},[s("li",[s("p",[t._v("diff 算法\nDiff算法是用于比较两个节点并返回一个patch对象，以更新DOM的操作。")]),t._v(" "),s("p",[t._v("在Vue中，Diff算法在虚拟DOM树从上至下进行同层比对，如果上层已经不同了，那么下面的DOM全部重新渲染。")]),t._v(" "),s("p",[t._v("特点：只会在同层级进行，不会跨层级比较。如果tag不相同，则直接删掉重建，不再深度比较；tag和key都相同，表示相同节点，不再深度比较。在diff比较的过程中，循环从两边向中间比较。")])]),t._v(" "),s("li",[s("p",[t._v("为什么只对对象劫持，而要对数组进行方法重写？")]),t._v(" "),s("p",[t._v("因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案")])])]),t._v(" "),s("p",[t._v("12.请谈谈在Vue.js项目中如何进行性能优化，并列举一些实用的优化技巧和工具。")]),t._v(" "),s("p",[t._v("组件级别的优化")]),t._v(" "),s("p",[t._v("使用v-if来控制DOM的数量：如果你的组件只有一部分时间需要被渲染，可以使用v-if来控制是否渲染组件。这可以减少不必要的DOM操作。\n使用v-show代替v-if来优化性能：v-show只是简单地切换CSS的display属性，而不是进行DOM操作。在某些情况下，这可以比v-if更快。\n使用vue-memo进行组件缓存：vue-memo是一个Vue插件，它可以帮助你避免不必要的组件重新渲染。你可以在组件中使用export default vue.memo(YourComponent)来启用缓存。")]),t._v(" "),s("p",[t._v("异步加载和代码分割")]),t._v(" "),s("p",[t._v("使用import()进行代码分割：import()语法可以让你动态地加载JavaScript模块。这允许你只在需要的时候加载和解析模块，从而提高应用程序的启动速度。\n使用vue-async-component进行异步组件加载：vue-async-component是一个Vue插件，它可以让你将组件的加载和渲染过程分开，从而提高应用程序的性能。")]),t._v(" "),s("p",[t._v("优化渲染")]),t._v(" "),s("p",[t._v("使用computed属性进行计算属性的缓存：computed属性是Vue中的一种特殊属性，它可以让你更有效地处理需要进行复杂计算的数据。一旦计算属性的结果被计算出来，它就会被缓存起来，并且在后续的渲染过程中可以直接使用，从而提高应用程序的性能。\n使用watch和watchEffect进行数据响应式的优化：在Vue中，你可以使用watch和watchEffect函数来监听数据的变化。如果你只需要在数据变化时执行一次或几次操作，你可以使用这些函数来代替computed属性或方法，从而提高应用程序的性能。")]),t._v(" "),s("p",[t._v("工具")]),t._v(" "),s("p",[t._v("使用Vue Devtools进行性能分析：Vue Devtools是一个浏览器插件，它可以让你在开发过程中查看和分析你的Vue应用程序的性能。它可以帮助你找出应用程序中的性能瓶颈，并提供一些优化建议。\n使用Lighthouse进行网页性能分析：Lighthouse是一个浏览器扩展程序，它可以自动分析网页的性能并给出一些优化建议。它可以帮助你找出你的Vue应用程序中的性能问题，并提供一些实用的优化技巧。")]),t._v(" "),s("p",[t._v("懒加载和按需加载")]),t._v(" "),s("p",[t._v("使用vue-lazyload进行图片懒加载：vue-lazyload是一个Vue插件，它可以让你延迟加载页面上的图片，从而提高应用程序的性能。\n使用Webpack进行按需加载：Webpack是一个前端开发工具，它可以让你将应用程序分割成多个小块，并且只在需要的时候加载这些小块。这可以帮助你减少应用程序的初始加载时间，从而提高应用程序的性能。")]),t._v(" "),s("p",[t._v("利用CDN资源")]),t._v(" "),s("p",[t._v("使用CDN来分发静态资源：通过将静态资源（如CSS、JavaScript、图片等）放在CDN上，可以让用户直接从距离他们最近的服务器获取这些资源，从而提高应用程序的性能。")]),t._v(" "),s("p",[t._v("服务器端渲染(SSR)")]),t._v(" "),s("p",[t._v("使用Vue Server Renderer进行服务器端渲染：服务器端渲染可以在服务器上预先渲染应用程序的HTML，然后发送到客户端。这可以提高应用程序的初始加载速度，并且对于搜索引擎优化（SEO）也有好处。")]),t._v(" "),s("p",[t._v("全局状态管理")]),t._v(" "),s("p",[t._v("使用Vuex进行全局状态管理：Vuex是Vue的一个插件，它可以让你在应用程序的各个部分之间共享状态（即数据）。通过避免在各个组件中重复创建和销毁相同的状态，可以减少应用程序的内存使用，从而提高应用程序的性能。")]),t._v(" "),s("p",[t._v("利用Web Workers进行重计算优化")]),t._v(" "),s("p",[t._v("如果你的Vue应用涉及到大量的计算或者重渲染，你可以考虑将部分重计算的工作移到Web Workers中去执行。Web Workers是浏览器提供的一种在后台线程中运行JavaScript的方法，它们不会影响页面的性能。对于那些计算密集型的任务，比如科学计算、数据处理等，Web Workers可以很好地提高应用的性能。\n记住，优化应当始终围绕着你的具体需求来进行。只有当你确定你的Vue应用存在性能问题时，才需要进行性能优化。以上提到的一些优化技巧和工具可能会根据你的应用程序的具体情况而有所不同。")]),t._v(" "),s("p",[t._v("13.Vue.js在未来的发展中会有哪些变化和趋势？请根据现有的信息进行预测和分析。")]),t._v(" "),s("p",[t._v("Vue.js自发布以来，已经成为了极其受欢迎的JavaScript框架之一。根据目前的发展趋势和社区讨论，以下是一些可能在Vue.js未来发展中可能出现的变化和趋势：")]),t._v(" "),s("p",[t._v("更强大的生态系统：Vue.js的生态系统正在持续增长，未来可能会看到更多的工具、库和插件出现，如专门用于测试、状态管理、路由、构建工具等。此外，随着Vue.js的成熟，可能会有更多的开发者构建基于Vue.js的生态系统，例如类似于React的Redux或者Vue自己的Vuex等状态管理库。")]),t._v(" "),s("p",[t._v("更好的性能优化：Vue.js的性能优化一直是其强项之一，但是在未来，我们可能会看到Vue.js在这方面有更多的突破。例如，Vue.js可能会引入更高效的响应式系统，或者提供更多内置的性能优化工具和功能。")]),t._v(" "),s("p",[t._v("更深入的集成和结合：Vue.js已经有了与React、Angular等其他框架的集成，未来可能会看到更多的这种集成。同时，Vue.js可能会与更多后端技术（如Nuxt.js与PWA、SSR等）进行更深入的结合，提供更完整的前后端解决方案。")]),t._v(" "),s("p",[t._v("更好的学习曲线和文档：随着Vue.js的持续发展，可能会看到更多的教程、学习资源和示例出现，这将使得学习Vue.js变得更加容易，同时也会吸引更多的新手开发者。")]),t._v(" "),s("p",[t._v("响应式和可访问性增强：随着移动设备和无障碍技术的日益普及，Vue.js可能会更加注重响应式设计和无障碍访问。例如，我们可能会看到Vue.js内置更多的无障碍特性，或者有更多的工具和插件来帮助开发者实现这些目标。")]),t._v(" "),s("p",[t._v("新的指令和特性：Vue.js可能会引入新的内置指令和特性，例如更强大的条件渲染、更灵活的事件处理等。此外，Vue.js也可能会提供更多的钩子和生命周期回调函数，以便于开发者在更多的时候进行定制操作。")]),t._v(" "),s("p",[t._v("更好的国际化支持：随着全球化的趋势，Vue.js可能会提供更好的多语言支持，包括对不同国家/地区的特殊格式、日期、时间等的更好支持。")]),t._v(" "),s("p",[t._v("总的来说，Vue.js的发展前景看起来非常光明。其灵活性和性能将继续吸引开发者，而其生态系统的发展也将使得开发者能够更容易地解决各种问题。无论未来的发展如何，我们都应该能够从中学到很多新的东西。")])])}),[],!1,null,null,null);s.default=n.exports}}]);